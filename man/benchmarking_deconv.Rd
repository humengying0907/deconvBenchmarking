% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/benchmarking.R
\name{benchmarking_deconv}
\alias{benchmarking_deconv}
\title{Perform deconvolution on the benchmarking_obj}
\usage{
benchmarking_deconv(
  benchmarking_obj,
  marker_based_methods = c("firstPC", "gsva", "debCAM", "TOAST"),
  regression_based_methods = c("nnls", "cibersort", "MuSiC", "wRLM", "RPC"),
  cibersort_path = NULL,
  scExpr = NULL,
  scMeta = NULL,
  colnames_of_cellType = NA,
  colnames_of_sample = NA,
  refFree_methods = c("linseed", "debCAM"),
  k = NA,
  immunedeconv_methods = c("xcell", "mcp_counter", "epic", "quantiseq", "timer", "abis",
    "consensus_tme", "estimate"),
  tcga_abbreviation = NA,
  n.core = 1,
  ...
)
}
\arguments{
\item{benchmarking_obj}{a benchmarking_obj generated from benchmarking_init() function}

\item{marker_based_methods}{a character vector indicating which methods to use for marker_based deconvolution.
Use \code{\link{list_deconv_marker}} to check for available method names and suggested packages associated them.
Make sure you have the required packages installed to use these methods. Set to NULL if no bulk simulation is needed. Set to NULL if no marker_based deconvolution is needed.}

\item{regression_based_methods}{a character vector indicating which methods to use for regression_based deconvolution.
Use \code{\link{list_deconv_regression}} to check for available method names and suggested packages associated them.
Make sure you have the required packages installed to use these methods. Set to NULL if no bulk simulation is needed. Set to NULL if no regression_based deconvolution is needed.}

\item{cibersort_path}{path to CIBERSORT.R. This argument is required for 'cibersort' regression method}

\item{scExpr}{Single-cell expression matrix used to simulate bulk data the benchmarking_obj, with genes in rows and cells in columns. This argument is required for 'MuSiC'
as they rely on a reference single-cell profile in their methods. Note that only training cells in the benchmarking_obj will be used to create a single-cell reference for 'MuSiC'}

\item{scMeta}{dataframe that stores annotation info of each cells, rownames of scMeta should be equal to colnames of scExpr. This argument is required for 'MuSiC'}

\item{colnames_of_cellType}{column name that corresponds to cellType in scMeta. This argument is required for 'MuSiC'}

\item{colnames_of_sample}{column name that corresponds to sampleID in scMeta. This argument is required for 'MuSiC'}

\item{refFree_methods}{a character vector indicating which methods to use for reference free deconvolution. Use \code{\link{list_deconv_refFree}} to check for available method names
and suggested packages associated them. Make sure you have the required packages installed to use these methods.Set to NULL if no bulk simulation is needed..}

\item{k}{argument for reference free methods: number of cell types in bulk expression. If set to NA, will be default to true number of cell types in bulk expression}

\item{immunedeconv_methods}{a character vector indicating which methods to use from immunedeconv package. Available methods include:
'xcell','mcp_counter','epic','quantiseq','timer','abis','consensus_tme','estimate'. Make sure you have the suggested package'immunedeconv' installed before using immunedeconv methods.
Set to NULL if no immunedeconv_methods is needed.}

\item{tcga_abbreviation}{a character string indicating tcga-abbreviation for the bulk data to be deconvoluted, for example 'skcm'. Required for 'timer' and 'consensus_tme'.}

\item{n.core}{number of cores to use for parallel programming. Default = 1}

\item{...}{additional arguments to be passed to the following functions: deconv_marker(), deconv_regression(), deconv_refFree(), and immunedeconv::deconvolute()}
}
\value{
a list of deconvolution results for each bulk expression in the benchmarking_obj
}
\description{
Perform deconvolution on the benchmarking_obj
}
\examples{
\dontrun{
# first create a benchmarking_obj using benchmarking_init():
benchmarking_init(scExpr = scExpr,
                  scMeta = scMeta,
                  colnames_of_cellType = 'cell_type',
                  colnames_of_sample = 'sampleID',

                  # argument for fracSimulator_Beta()
                  nbulk = 100,
                  fixed_cell_type = 'malignant',

                  # argument for training/testing splitting:
                  training_ratio = 0.5,
                  split_by = "cell",

                  # arguments for bulk simulation: select bulk simulation methods
                  bulkSimulator_methods = c('homo','semi','heter','heter_sampleIDfree'),

                  # argument required for semi/heter_sampleIDfree bulk simulation method
                  heter_cell_type = 'malignant',

                  # general simulation parameters
                  ncells_perSample = 500,
                  min_chunkSize = 20,
                  use_chunk = 'random',

                  # parameters for adjusting heterogeneity in sample ID-free bulk simulation
                  dirichlet_cs_par = 0.1,
                  min.subcluster.size = 20,
                  max.num.cs = NA,

                  # argument for marker constructions
                  refMarkers_methods = c('limma','scran'),

                  # arguments for signature matrics construction
                  refMatrix_methods = c('raw','limma','scran'),


                  # export files for autogeneS and cibersortx
                  create_autogeneS_input = T,
                  create_cibersortx_input = T,

                  n.core = 4
                  )

# perform deconvolution on the benchmarking_obj using all categories of deconvolution methods, which includes:
# 1) marker-based methods: 'firstPC','gsva','debCAM','TOAST'
# 2) regression-based methods: 'nnls','cibersort','MuSiC','wRLM','RPC'
# 3) reference free methods: 'linseed','debCAM'
# 4) other deconvolution methods from immunedeconv package:
#     'xcell','mcp_counter','epic','quantiseq','timer','abis','consensus_tme','estimate'
benchmarking_deconv(benchmarking_obj,

                    # arguments for marker based methods
                    marker_based_methods = c('firstPC','gsva','debCAM','TOAST'),

                    # arguments for regression-based methods
                    regression_based_methods =  c('nnls','cibersort','MuSiC','wRLM','RPC'),
                    cibersort_path = 'scripts/', # argument required for 'cibersort' method
                    scExpr = scExpr, # arguments required for 'MuSiC'
                    scMeta = scMeta,
                    colnames_of_cellType = 'cell_type',
                    colnames_of_sample = 'sampleID',

                    # arguments for reference-free methods
                    refFree_methods = c('linseed','debCAM'),

                    # arguments for other deconvolution methods
                    immunedeconv_methods = c('xcell','mcp_counter','epic','quantiseq','timer','abis','consensus_tme','estimate'),
                    tcga_abbreviation = 'SKCM', # arguments required for 'timer' and 'consensus_tme'

                    n.core = 4)

# if only marker-based deconvolution and regression-based deconvolution is needed
benchmarking_deconv(benchmarking_obj,
                    marker_based_methods = c('firstPC','gsva','debCAM','TOAST'),

                    regression_based_methods =  c('nnls','cibersort','MuSiC','wRLM','RPC'),
                    cibersort_path = 'scripts/',  # argument required for 'cibersort' method
                    scExpr = scExpr, # arguments required for 'MuSiC'
                    scMeta = scMeta,
                    colnames_of_cellType = 'cell_type',
                    colnames_of_sample = 'sampleID',

                    # set methods argument to NULL to disable deconvolution with these methods
                    refFree_methods = NULL,
                    immunedeconv_methods = NULL,

                    n.core = 4)

}
}
